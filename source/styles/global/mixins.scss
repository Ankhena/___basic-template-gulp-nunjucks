@use "sass:math";
// для подключения модуля math в scss
@use "sass:string";
// для работы со строками

@use "sass:map";
// для работы с map массивов (для @media)

@use "sass:meta";
// для работы meta.type-of вместо type-of (для @media)

@use "variables";


//vw
$layout-width: 1900; //указываем ширину макета, от которой вычисляем vw

@function vw($size) {
  @return #{(math.div($size, $layout-width)*100)}vw;
}

@function clampvw($min, $max) {
  @return clamp(#{$min}px,  #{(math.div($max, $layout-width)*100)}vw, #{$max}px);
}


// Применение функций vw и clamp
//.dd {
//  font-size: vw(120);
//}
//.dd {
//  font-size: clampvw(18,120);
//}


// функция, которая переведет px в vw
// и в итоге запретит увеличиваться больше, чем было px при макетной ширине
// не нужно будет писать лишние media
// тут используется в основном для padding крупных секций

@function min-px-vw($size) {
  // но нужно экранировать min, т.к. зарезервированная функция scss
  @return #{"min("}$size+px, (math.div($size, $layout-width)*100)+vw#{")"};
}



// ///////////////////////////////////////// //
//media

/// Универсальный миксин, поддерживает 'min', 'max' и 'range'
// ///////////////////
// media
// @include mixins.media(esm) -> mobile-first
// @include mixins.media(esm, max) -> @media (max-width: 1023.98px)
// @include mixins.media(sm, elg, range) -> @media (min-width: sm) and (max-width: elg - 0.02px)

@mixin media($key, $mode-or-max-key: min, $range-flag: null) {
  $value: null;
  $max-value: null;
  $mode: min;

  // Определяем режим использования
  @if $range-flag == range {
    // Режим интервала: $key = min, $mode-or-max-key = max
    $mode: range;
    $max-value: get-media-value($mode-or-max-key);
  } @else {
    // Обычный режим: $key = ключ, $mode-or-max-key = min/max
    $mode: $mode-or-max-key;
  }

  // Получаем основное значение
  $value: get-media-value($key);

  // Если value остался null — выводим предупреждение и НЕ вставляем @content
  @if $value == null {
    @warn "media: unsupported key `#{$key}`; expected key from variables.$sizes, number or px string.";
  }
  @else if $mode == range and $max-value == null {
    @warn "media: unsupported max key `#{$mode-or-max-key}` for range mode";
  }
  @else {
    // Проверяем корректность режима
    @if not ($mode == min or $mode == max or $mode == range) {
      @warn "media: unknown mode `#{$mode}`, expected 'min', 'max' or 'range'. Falling back to 'min'.";
      $mode: min;
    }

    // Преобразуем все значения к числу для consistent поведения
    $numeric-value: if(meta.type-of($value) == 'number', $value, meta.inspect($value));

    @if $mode == max {
      // Для max-width всегда вычитаем 0.02px чтобы избежать пересечений
      $limit: if(meta.type-of($numeric-value) == 'number', $numeric-value - 0.02, $numeric-value);
      @media (width <= #{$limit}) {
        @content;
      }
    } @else if $mode == range {
      // Для интервала: min-width и max-width с вычитанием 0.02px
      $numeric-max-value: if(meta.type-of($max-value) == 'number', $max-value, meta.inspect($max-value));
      $max-limit: if(meta.type-of($numeric-max-value) == 'number', $numeric-max-value - 0.02, $numeric-max-value);

      @media (width >= #{$numeric-value}) and (width < #{$max-limit}) {
        @content;
      }
    } @else {
      // min-width (по умолчанию)
      @media (width >= #{$numeric-value}) {
        @content;
      }
    }
  }
}

// Вспомогательная функция для получения значения медиа-запроса
@function get-media-value($key) {
  // 1) ключ из variables.$sizes
  @if meta.type-of($key) == 'string' and map.has-key(variables.$sizes, $key) {
    @return map.get(variables.$sizes, $key);
  }
    // 2) строка с 'px'
  @else if meta.type-of($key) == 'string' and string.index($key, 'px') {
    @return $key;
  }
    // 3) число (например 992px как number)
  @else if meta.type-of($key) == 'number' {
    @return $key;
  }
    // 4) строка из цифр, добавляем px
  @else if meta.type-of($key) == 'string' {
    $digits-only: true;
    @for $i from 1 through str-length($key) {
      $ch: str-slice($key, $i, $i);
      @if not str-index("0123456789", $ch) {
        $digits-only: false;
      }
    }
    @if $digits-only {
      @return $key + px;
    }
  }

  @return null;
}
// end media
////////////////
// ///////////////////////////////////////// //



@function str-replace($string, $search, $replace: "") {
  $index: str-index($string, $search);

  @if $index {
    @return str-slice($string, 1, $index - 1) + $replace + str-replace(str-slice($string, $index + str-length($search)), $search, $replace);
  }

  @return $string;
}

////Usage:
//.selector {
//  $string: 'The answer to life the universe and everything is 42.';
//  content: str-replace($string, 'e', 'xoxo');
//}
////Result:
//.selector {
//  content: "Thxoxo answxoxor to lifxoxo thxoxo univxoxorsxoxo and xoxovxoxorything is 42.";
//}

//Для цвета в SVG
//
//$bright: #6dace2;
//$fill: str-replace($bright, '#', '%23');
//в самой svg fill='#{$fill}'


@mixin container {

  width: 100%;
  //max-width: 360px;
  margin-left: auto;
  margin-right: auto;
  padding-left: var(--x-padding, 10px);
  padding-right: var(--x-padding, 10px);

  //outline: 1px solid deepskyblue;
  //overflow-x: hidden;

  @include media(lg) {
    --w: #{clampvw(770, 1720)};
    --p: calc((100vw - var(--w)) / 2);
    //--p: calc((100vw - 1520px)/2);
    //max-width: $lg;
    max-width: clampvw(770, 1520); // чтобы были пропорциональные поля

    // переведем в padding
    // если переводить в padding, то потом у дочерних не работает max-width 100%
    // или это из-за фокуса флексов, решаемых min-width: 0;
    // проверь
    //padding-left: var(--p);
    //padding-right: var(--p);
  }
}

@mixin container-padding {
  padding-left: var(--x-padding, 10px);
  padding-right: var(--x-padding, 10px);
}

@mixin visually-hidden {
  position: fixed;
  transform: scale(0);
  color: inherit; // для того, чтобы не ругалось на контраст
}

@function opacity($color, $percent) {
  @return color-mix(in sRGB, $color $percent, transparent);
}

@mixin scroll() {
  --scroll-size: 6px;
  --scroll-color: var(--color-scroll, #ff0000);
  scrollbar-color: var(--scroll-color) rgba(0, 0, 0, 0.4); // FF цвет-ползунка цвет-полосы
  scrollbar-width: thin; // FF, auto, thin, none

  &::-webkit-scrollbar {
    width: var(--scroll-size);
    height: var(--scroll-size);
  }

  &::-webkit-scrollbar-track {
    background: linear-gradient(transparent calc(50% - 1px), var(--scroll-color) calc(50% - 1px), var(--scroll-color) calc(50% + 1px), transparent calc(50% + 1px));
    border-radius: 6px;
  }

  &::-webkit-scrollbar-track:vertical {
    background: linear-gradient(to right, transparent calc(50% - 1px), var(--scroll-color) calc(50% - 1px), var(--scroll-color) calc(50% + 1px), transparent calc(50% + 1px));
    border-radius: 6px;
  }

  &::-webkit-scrollbar-thumb {
    height: var(--scroll-size);
    width: var(--scroll-size);
    border-radius: 6px;
    background: var(--scroll-color);
    box-shadow: inset 0 0 4px rgba(0, 0, 0, 0.3);
  }

  &::-webkit-scrollbar-thumb:vertical {
    height: var(--scroll-size);
  }

  &::-webkit-scrollbar-thumb:window-inactive {
    //background: rgba(green, 0.3);
  }
}


// Для этой функции нужен @use "sass:string"; в начале файла
@function image-set($file-name) {
  $dot-pos: string.index($file-name, ".");

  @if $dot-pos == null {
    @error "Файл должен содержать расширение, например 'puppy.png'";
  }
  $ext: string.slice($file-name, $dot-pos + 1);
  $base-name: string.slice($file-name, 1, $dot-pos - 1);

  $result: "image-set(url(\"../../images/#{$base-name}@1x.webp\") type(\"image/webp\") 1x, url(\"../../images/#{$base-name}@2x.webp\") type(\"image/webp\") 2x, url(\"../../images/#{$base-name}@1x.#{$ext}\") type(\"image/#{$ext}\") 1x, url(\"../../images/#{$base-name}@2x.#{$ext}\") type(\"image/#{$ext}\") 2x)";

  @return string.unquote($result);
}

// Пример использования
/*
.intro {
  background: mixins.image-set("bg.jpg") no-repeat top center / cover;
}
*/


// ////////////
// Project mixins

